# [BaekJoon] 계단 오르기 2579
#### 실행시간 : 76ms  
dp활용
연속해서 3칸 밟으면 안되므로 먼저 3번칸까지 값을 따로 처리해줌  
4번 칸부터 n번 칸을 도달할 수 있는 1칸, 2칸->1칸인 경우 중 최대 값을 구함  
계단이 1,2,3인 경우 각각 예외처리 !! 



# [BaekJoon] 통나무 옮기기 1938  
#### 실행시간 : 96ms  
BFS    
통나무를 가로방향이면 맨 왼쪽점, 세로방향이면 맨 윗쪽점으로 생각하고 품, 점의 cnt요소가 이동 횟수, dir요소가 세로방향or가로방향을 의미  
visited배열로 방문 체크, 가로방향과 세로방향 경우를 나누어서 생각해해야 하므로 3차원배열을 활용함  
queue를 활용하여 꺼내고, 통나무 3칸 모두 범위 검사하여 E에 도달하는지 체크, 다음 방향으로 가기 위해 4방향 체크를 먼저 진행  
4방향 체크 후 check변수 활용하여 true면 갈 수 있으므로 visited배열 true로, queue에 점 하나 넣기  
회전인 경우 따지기 위해 checkRotate함수로 가운데 점 기준으로 8방향 체크 -> true면 회전 가능하므로 visited배열 true여부 체크 후 방문하지 않았다면 true로 체크하고, 통나무의 dir을 변경하여 queue에 넣어줌  



# [Programmers] 문자열 압축 1952  
#### 실행시간 : 테스트 21 〉	통과 (4.26ms, 52.6MB)  
1부터 문자열 길이만큼까지 경우의 수를 따져줌  
자른 만큼의 문자열을 담아 놓고, 다음 자른 문자열과 비교 후 같으면 개수 세어주기, 다르면 출력  
출력 시 1이면 생략이므로 반복 문자열 길이만큼만 result에 더해주고, 그렇지 않으면 개수와 함께 반복 문자열 길이를 result에 더해줌, 그리고 count와 반복문자열을 변경해줌, 그 후 인덱스를 자른 길이 만큼 반복해서 바꿔줌   
마지막 문자열은 count만 세고 while문을 빠져나오므로 result값 정해주고, 더 이상 자를 수 없으므로 남은 문자열 길이만큼 붙여줌  





