# [BaekJoon] 테트로미노 14500 
#### 실행 시간 : 696ms  
dfs 활용  
주어진 5가지 모양에서 나머지 모양은 dfs로 해결 가능하지만, ㅗ 모양은 불가능하므로 따로 처리하였음  
나머지 모양을 만들 때 처음에 한 가지 점을 골라서 dfs를 하였지만 시간 초과 오류가 발생하여 두 가지 점을 고르고 나머지를 dfs하는 방식으로 변경함  
dfs를 돌릴 때 종료조건으로 count가 4이면 최대 값을 구하게 함, visited배열을 활용하여 이미 고른 점을 고르지 않도록 하였음  
ㅗ 와 같은 모양을 처리할 때에는 한 점에 대하여 상하좌우를 검사하면서 count와 min,sum값을 구하게 되는데 이때 count가 3이면 sum과 최대 값을 비교하여 결과를 구하고, count가 4이면 하나의 블럭을 버려주어야 하는데 이때 최대 값을 구하면 되는 것이므로 구해놓았던 min값을 sum에서 빼준 값으로 최대 값을 비교하여 결과를 구한다.  



# [BaekJoon] 낚시왕 17143  
낚시왕이 상어 죽이기 -> 상어 이동 -> 같은 곳 상어 죽이기  
상어 정보를 입력받아 Queue로 만들어서 관리  
index변수로 낚시왕 위치 관리, index 위치에 있는 상어 찾는데 이때 가장 x좌표가 작은 상어 저장해두고, 상어 객체 죽이기  
상어 speed만큼 이동하는데 범위 벗어나면 (벗어나기 전까지 가다가 방향바꾸고) 이를 반복 후 우선순위 큐에 모두 넣음  
우선순위 큐를 사용하여 큰 값이 먼저 나오게 하여 크기가 가장 큰 상어만 남기고 다 죽인다, HashMap을 활용하여 우선순위 큐에서 꺼낸 순서대로 넣고 이미 존재한다면 버린다. 이 값들을 다시 큐에 넣고 반복  
!!! 상어가 한 칸씩 이동하게 할 경우 시간초과가 난다는 점을 유의  



# [BaekJoon] 경사로 14890    
#### 실행 시간 : 100ms  
시뮬레이션, 행과 열 검사 부분을 따로 만들었지만 내용은 비슷함  
while문으로 처음 한 점을 고른 곳에서 시작하여 맨 끝으로 가게되거나 앞 칸과의 차이의 절대 값이 1보다 크면 불가능한 경우이므로 종료     
내리막길/오르막길/평평한길 세 가지 경우가 존재하여 if문으로 경우를 나누어 처리함  

1) 내리막길 : 내리막길인 경우에는 현재 칸 다음으로 다음 칸 값인 경사로의 길이이상의 칸 개수가 존재해야함 => while문으로 다음 칸 값이 달라지거나 범위를 벗어날 때까지 개수를 세고, 개수가 길이미만인 경우와 사용한 경사로 길이만큼 이동한 위치가 범위를 벗어나지 않으면서 경사로 길이만큼 세운 후 다음 칸이 경사로 세운 칸의 값보다 크면 경사로를 세워야하는데 불가능하므로 check를 false로 변경하고 종료한다. 그 후 경사로를 세운 다음 칸을 검사하기 위해 size를 경사로 세운 칸의 값으로, count는 경사로를 사용한 만큼을 뺀 값으로, 위치는 다음 칸의 위치로 변경한다   
2) 오르막길 : 오르막길은 내리막길과 달리 오르막길인지 판단하기 전 개수를 세주어야 한다. 센 개수가 경사로 길이보다 작으면 check를 false로 변경하고 종료한다. 그렇지 않으면 경사로 세우는 것이 가능하므로 다음 칸을 검사하기 위해 size는 다음 칸의 값으로, count는 다음 칸 값의 개수 1로, 위치는 다음 칸의 위치로 변경한다.    
3) 평평한 길 : 평평한 길은 개수를 세고 다음 위치로 변경해주면 됨  

while문 종료 후 check가 true이고 dy가 위치를 벗어나면 지나갈 수 있는 길이므로 answer값 증가  



# [SWEA] 숫자 만들기 4008  
재귀 활용  
연산자를 받아서 배열로 관리  
숫자는 순서가 바뀌지 않으므로 재귀를 활용하여 부호의 경우의 수를 따져준다.  
이때 파라미터에 숫자의 index를 가지고 호출하며 종료 조건은 숫자의 크기에 도달했을 때이다.   
